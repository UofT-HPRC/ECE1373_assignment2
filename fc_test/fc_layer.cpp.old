#include <algorithm>
#include <ap_utils.h>
#include "fc_layer.h"

void fc_layer(
	      float * mem,
	      int input_offset,
	      int output_offset,
              const int batch_size,
              const int num_inputs,
              const int num_outputs)
{
#pragma HLS INTERFACE m_axi port=mem depth=2147483648
#pragma HLS INTERFACE s_axilite port=input_offset bundle=CTRL_BUS
#pragma HLS INTERFACE s_axilite port=output_offset bundle=CTRL_BUS
#pragma HLS INTERFACE s_axilite port=batch_size bundle=CTRL_BUS
#pragma HLS INTERFACE s_axilite port=num_inputs bundle=CTRL_BUS
#pragma HLS INTERFACE s_axilite port=num_outputs bundle=CTRL_BUS
#pragma HLS INTERFACE s_axilite port=return bundle=CTRL_BUS

  float weights[MAX_INPUT_SIZE*MAX_OUTPUT_SIZE];
  float biases[MAX_OUTPUT_SIZE];
  float input[MAX_INPUT_SIZE*MAX_BATCH];
  float output[MAX_OUTPUT_SIZE*MAX_BATCH];
 
  //int num_weights = num_inputs*num_outputs;
  //int num_biases =  num_outputs;

  const int num_weights = 4096*1000;
  const int num_biases =  1000;

 
 // memcpy(weights, mem + input_offset/sizeof(float), num_weights*sizeof(float)); 
 // memcpy(biases, mem + (input_offset/sizeof(float)) + num_weights, num_biases*sizeof(float)); 
 // memcpy(input, mem + (input_offset/sizeof(float)) + (num_biases+num_weights), batch_size*num_inputs*sizeof(float)); 
  // Batch Iterator
  //for (int b = 0; b < batch_size; b++) {
  for (int b = 0; b < 10; b++) {

    // Output Node Iterator
    for (int o = 0; o < 1000; o++) {

      // Set bias
//      output[b*num_outputs+o] = biases[o];
//      float output_element = *(mem + input_offset + num_weights + o);
      float output_element = mem[input_offset + num_weights + o];
	
      // Accumulate weighted sum
      for (int i = 0; i < 4096; i++) {
//        output[b*num_outputs+o] += input[b*num_inputs+i]*weights[o*num_inputs+i];
//	float input_element = *(mem + input_offset + num_weights + num_biases + b*num_inputs*i);
//	float weight_element = *(mem + input_offset + o*num_inputs+i);
	float input_element = mem[input_offset + num_weights + num_biases + b*num_inputs+i];
	float weight_element = mem[input_offset + o*num_inputs+i];
        output_element += input_element * weight_element ;
      }

      // Compute activation

      mem[output_offset + b*1000+o] = std::max(0.0f, output_element);
      //*(mem + output_offset + b*num_outputs+o) = std::max(0.0f, output_element);
    }
  }
  //return mem[output_offset];
//  return *(mem + output_offset);
 // memcpy(mem + (output_offset/sizeof(float)), output, num_outputs*batch_size*sizeof(float)); 
}
